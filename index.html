<!DOCTYPE html>
<html lang="en" class="scroll-smooth" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Street Cricket Scorer</title>
  
  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            slate950: '#0f172a',
            accentBlue: '#2563eb',
            accentGreen: '#22c55e',
          },
          animation: {
            'pulse-green': 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
            spin-slow: 'spin 4s linear infinite',
          },
        },
      },
    }
  </script>

  <!-- React + ReactDOM CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <!-- jsPDF for PDF generation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <style>
    body {
      background-color: #0f172a;
      color: white;
    }
    .striker {
      animation: pulse 2s infinite;
      animation-name: pulse-green;
    }
  </style>
</head>
<body class="dark bg-slate950 min-h-screen flex flex-col items-center p-4 font-sans">

  <div id="root" class="w-full max-w-3xl"></div>

  <script type="text/javascript">
    const { useState, useEffect, useRef } = React;
    const { jsPDF } = window.jspdf;

    // Utils
    function saveToLocalStorage(key, data) {
      localStorage.setItem(key, JSON.stringify(data));
    }

    function loadFromLocalStorage(key, defaultValue) {
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return defaultValue;
        return JSON.parse(raw);
      } catch {
        return defaultValue;
      }
    }

    // Constants
    const MAX_OVERS = 15;
    const BALLS_PER_OVER = 6;
    const MAX_WICKETS = 2;
    const TEAM_SIZE = 3;
    const WICKET_TYPES = ['Bowled', 'LBW', 'Caught', 'Run Out'];
    const OUT_TYPES_WITH_FIELDER = ['Caught', 'Run Out'];

    // Initial career stats format
    /*
      {
        playerName: {
          runs: 0,
          balls: 0,
          wickets: 0,
          matches: 0
        }
      }
    */

    // Main App Component
    function App() {
      // ---- Career stats loaded from localStorage
      const [careerStats, setCareerStats] = useState(() => loadFromLocalStorage('careerStats', {}));

      // Save career stats every change
      useEffect(() => {
        saveToLocalStorage('careerStats', careerStats);
      }, [careerStats]);

      // ---- Game state
      const initialTeamPlayers = Array(TEAM_SIZE).fill('').map((_, i) => `Player ${i + 1}`);
      const [teamAPlayers, setTeamAPlayers] = useState(initialTeamPlayers);
      const [teamBPlayers, setTeamBPlayers] = useState(initialTeamPlayers);

      const [tossWinner, setTossWinner] = useState(null); // 'A' or 'B'
      const [tossChoice, setTossChoice] = useState(null); // 'bat' or 'bowl'
      const [matchStarted, setMatchStarted] = useState(false);

      // innings: 1 or 2 for teamA, 3 or 4 for teamB
      // innings 1: teamA batting, innings 2: teamB batting, innings 3: teamA 2nd innings, innings 4: teamB 2nd innings
      const [innings, setInnings] = useState(1);

      // Match data structure
      // For simplicity: An array of innings objects with ball by ball data
      // inningsData: [{balls: [], runs: 0, wickets: 0, striker: 0, nonStriker:1, currentBowler: null, overs: 0}]
      const [inningsData, setInningsData] = useState([
        createEmptyInnings(),
        createEmptyInnings(),
        createEmptyInnings(),
        createEmptyInnings()
      ]);

      // Current over ball count (0 to 5)
      const [currentBallInOver, setCurrentBallInOver] = useState(0);

      // Current striker and non-striker indexes
      const [strikerIndex, setStrikerIndex] = useState(0);
      const [nonStrikerIndex, setNonStrikerIndex] = useState(1);

      // Current bowler index (0 to 2)
      const [currentBowlerIndex, setCurrentBowlerIndex] = useState(null);

      // Current team batting ('A' or 'B')
      const [battingTeam, setBattingTeam] = useState('A');

      // Undo stack
      const undoStack = useRef([]);

      // Day end flag
      const [dayEnded, setDayEnded] = useState(false);

      // Extra runs input state for no ball run selection
      const [extraRunInput, setExtraRunInput] = useState(0);
      const [showExtraRunInput, setShowExtraRunInput] = useState(false);

      // Wicket fall info state
      const [wicketFalling, setWicketFalling] = useState(false);
      const [selectedWicketType, setSelectedWicketType] = useState(null);
      const [fielderPickerVisible, setFielderPickerVisible] = useState(false);
      const [fielderOptions, setFielderOptions] = useState([]);
      const [selectedFielder, setSelectedFielder] = useState(null);

      // Match end flag and winner info
      const [matchEnded, setMatchEnded] = useState(false);
      const [winnerTeam, setWinnerTeam] = useState(null);

      // Toss & match start UI states
      const [teamABattingChoice, setTeamABattingChoice] = useState(null);
      const [teamBBattingChoice, setTeamBBattingChoice] = useState(null);
      const [tossWinnerSelection, setTossWinnerSelection] = useState(null);
      const [tossChoiceSelection, setTossChoiceSelection] = useState(null);

      // Run rate
      const runRate = calculateRunRate(inningsData[innings-1]?.runs || 0, inningsData[innings-1]?.balls?.length || 0);
      const requiredRunRate = calculateRequiredRunRate();

      // For display & export, track all balls
      // ball structure: {runs: number, extra: null|'wide'|'noball', wicket: null|wicketType, fielder: null|string, batsmanRuns: number, bowlerIndex: number}

      // On mount load match state from localStorage if any
      useEffect(() => {
        const saved = loadFromLocalStorage('matchState', null);
        if (saved) {
          setTeamAPlayers(saved.teamAPlayers);
          setTeamBPlayers(saved.teamBPlayers);
          setTossWinner(saved.tossWinner);
          setTossChoice(saved.tossChoice);
          setMatchStarted(saved.matchStarted);
          setInnings(saved.innings);
          setInningsData(saved.inningsData);
          setCurrentBallInOver(saved.currentBallInOver);
          setStrikerIndex(saved.strikerIndex);
          setNonStrikerIndex(saved.nonStrikerIndex);
          setCurrentBowlerIndex(saved.currentBowlerIndex);
          setBattingTeam(saved.battingTeam);
          setDayEnded(saved.dayEnded);
          setMatchEnded(saved.matchEnded);
          setWinnerTeam(saved.winnerTeam);
          setTeamABattingChoice(saved.teamABattingChoice);
          setTeamBBattingChoice(saved.teamBBattingChoice);
          setTossWinnerSelection(saved.tossWinnerSelection);
          setTossChoiceSelection(saved.tossChoiceSelection);
        }
      }, []);

      // Save match state on update
      useEffect(() => {
        saveToLocalStorage('matchState', {
          teamAPlayers,
          teamBPlayers,
          tossWinner,
          tossChoice,
          matchStarted,
          innings,
          inningsData,
          currentBallInOver,
          strikerIndex,
          nonStrikerIndex,
          currentBowlerIndex,
          battingTeam,
          dayEnded,
          matchEnded,
          winnerTeam,
          teamABattingChoice,
          teamBBattingChoice,
          tossWinnerSelection,
          tossChoiceSelection,
        });
      }, [
        teamAPlayers, teamBPlayers, tossWinner, tossChoice, matchStarted,
        innings, inningsData, currentBallInOver, strikerIndex, nonStrikerIndex,
        currentBowlerIndex, battingTeam, dayEnded, matchEnded, winnerTeam,
        teamABattingChoice, teamBBattingChoice, tossWinnerSelection, tossChoiceSelection
      ]);

      // Helper to create empty innings data
      function createEmptyInnings() {
        return {
          balls: [],
          runs: 0,
          wickets: 0,
          overs: 0,
          striker: 0,
          nonStriker: 1,
          currentBowler: null,
          batsmanStats: Array(TEAM_SIZE).fill(0).map(() => ({
            runs: 0,
            balls: 0,
            fours: 0,
            sixes: 0,
            isOut: false,
            outType: null,
            fielder: null,
          })),
          bowlerStats: Array(TEAM_SIZE).fill(0).map(() => ({
            balls: 0,
            runsConceded: 0,
            wickets: 0,
          })),
        };
      }

      // Calculate run rate (runs per over)
      function calculateRunRate(runs, balls) {
        if (balls === 0) return 0;
        return (runs / balls) * BALLS_PER_OVER;
      }

      // Calculate required run rate
      function calculateRequiredRunRate() {
        // For 2nd innings of a team: runs required / balls left * 6
        if (!matchStarted) return 0;
        if (innings === 2) {
          // Team B chasing Team A score from innings 1
          const target = inningsData[0].runs + 1;
          const runsNeeded = target - inningsData[1].runs;
          const ballsLeft = (MAX_OVERS * BALLS_PER_OVER) - inningsData[1].balls.length;
          return ballsLeft > 0 ? (runsNeeded / ballsLeft) * BALLS_PER_OVER : 0;
        }
        if (innings === 4) {
          // Team B chasing Team A 2nd innings
          const target = inningsData[2].runs + 1;
          const runsNeeded = target - inningsData[3].runs;
          const ballsLeft = (MAX_OVERS * BALLS_PER_OVER) - inningsData[3].balls.length;
          return ballsLeft > 0 ? (runsNeeded / ballsLeft) * BALLS_PER_OVER : 0;
        }
        return 0;
      }

      // Handles ball input and scoring
      function onBall({
        runs = 0,
        extra = null,
        wicketType = null,
        fielder = null,
        batsmanRuns = 0,
        bowlerIndex = currentBowlerIndex,
      }) {
        if (dayEnded || matchEnded) return;

        // Undo push
        undoStack.current.push(JSON.parse(JSON.stringify(inningsData)));

        const newInningsData = [...inningsData];
        const currentInnings = { ...newInningsData[innings - 1] };
        currentInnings.balls = [...currentInnings.balls];
        currentInnings.batsmanStats = [...currentInnings.batsmanStats];
        currentInnings.bowlerStats = [...currentInnings.bowlerStats];

        // Ball object
        const ball = {
          runs,
          extra,
          wicket: wicketType,
          fielder,
          batsmanRuns,
          bowlerIndex,
        };

        currentInnings.balls.push(ball);

        // Update team runs - extras add 1 run extra, but batsmanRuns add separately
        let totalRunsThisBall = 0;
        if (extra === 'noball' || extra === 'wide') {
          // Extras + runs scored on no ball add 1 run extra for no ball or wide
          totalRunsThisBall = runs + 1;
          currentInnings.runs += totalRunsThisBall;
          // Runs to batsman only runs (not extra 1)
          if (extra === 'noball') {
            // Batsman gets batsmanRuns only, not extra run
            currentInnings.batsmanStats[strikerIndex].runs += batsmanRuns;
            currentInnings.batsmanStats[strikerIndex].balls += 0; // no ball doesn't count as ball faced
            // Bowler runs conceded includes total runs (batsman + extras)
            currentInnings.bowlerStats[bowlerIndex].runsConceded += totalRunsThisBall;
          } else if (extra === 'wide') {
            // Wide ball: batsman runs 0, bowler runs conceded + total
            currentInnings.bowlerStats[bowlerIndex].runsConceded += totalRunsThisBall;
          }
        } else {
          totalRunsThisBall = runs;
          currentInnings.runs += totalRunsThisBall;
          // Update batsman runs & balls
          currentInnings.batsmanStats[strikerIndex].runs += batsmanRuns;
          currentInnings.batsmanStats[strikerIndex].balls += 1;
          // Bowler stats
          currentInnings.bowlerStats[bowlerIndex].runsConceded += totalRunsThisBall;
          currentInnings.bowlerStats[bowlerIndex].balls += 1;
        }

        // Handle wickets
        if (wicketType) {
          currentInnings.wickets++;
          currentInnings.batsmanStats[strikerIndex].isOut = true;
          currentInnings.batsmanStats[strikerIndex].outType = wicketType;
          currentInnings.batsmanStats[strikerIndex].fielder = fielder;

          // Update bowler wicket count (except Run Out)
          if (wicketType !== 'Run Out') {
            currentInnings.bowlerStats[bowlerIndex].wickets++;
          }
        }

        // Update overs and balls
        if (extra !== 'noball' && extra !== 'wide') {
          // Legit ball count
          const newBallInOver = currentBallInOver + 1;
          setCurrentBallInOver(newBallInOver);

          if (newBallInOver === BALLS_PER_OVER) {
            // Over completed
            currentInnings.overs++;
            setCurrentBallInOver(0);

            // Swap strike
            const oldStriker = strikerIndex;
            setStrikerIndex(nonStrikerIndex);
            setNonStrikerIndex(oldStriker);

            // Show select new bowler popup (for simplicity, prompt)
            alert('Over complete! Please select new bowler.');
            // Select new bowler
            const newBowler = prompt(
              `Select new bowler (0,1,2):\n${battingTeam === 'A' ? teamBPlayers : teamAPlayers
              }`
            );
            if (newBowler !== null && ['0', '1', '2'].includes(newBowler)) {
              setCurrentBowlerIndex(parseInt(newBowler));
              currentInnings.currentBowler = parseInt(newBowler);
            }
          }
        }

        // Strike rotation for 1 or 3 runs (only if runs scored and no extras wide/noball)
        if (!extra && (runs === 1 || runs === 3)) {
          const oldStriker = strikerIndex;
          setStrikerIndex(nonStrikerIndex);
          setNonStrikerIndex(oldStriker);
        }

        // Handle wicket max or overs max to end innings
        if (currentInnings.wickets >= MAX_WICKETS || currentInnings.overs >= MAX_OVERS) {
          alert(`Innings ${innings} over!`);
          // Move to next innings or end match
          if (innings < 4) {
            setInnings(innings + 1);
            // Reset striker and non-striker for new innings
            setStrikerIndex(0);
            setNonStrikerIndex(1);
            // Toggle batting team
            setBattingTeam(innings + 1 === 2 || innings + 1 === 4 ? (battingTeam === 'A' ? 'B' : 'A') : battingTeam);
            setCurrentBallInOver(0);
            setCurrentBowlerIndex(null);
          } else {
            // Match ended
            setMatchEnded(true);
            calculateWinner();
          }
        }

        newInningsData[innings - 1] = currentInnings;
        setInningsData(newInningsData);

        // Update career stats for batsman and bowler
        updateCareerStatsAfterBall(
          battingTeam === 'A' ? teamAPlayers[strikerIndex] : teamBPlayers[strikerIndex],
          battingTeam === 'A' ? teamAPlayers[currentBowlerIndex] : teamBPlayers[currentBowlerIndex],
          runs,
          wicketType,
          extra,
          batsmanRuns
        );
      }

      function updateCareerStatsAfterBall(batsman, bowler, runs, wicketType, extra, batsmanRuns) {
        setCareerStats(prevStats => {
          const newStats = { ...prevStats };

          // Update batsman
          if (!newStats[batsman]) {
            newStats[batsman] = { runs: 0, balls: 0, wickets: 0, matches: 0 };
          }
          if (!extra || extra === 'noball') {
            // Balls faced count except wides
            newStats[batsman].balls += 1;
          }
          newStats[batsman].runs += batsmanRuns;

          // Update bowler
          if (!newStats[bowler]) {
            newStats[bowler] = { runs: 0, balls: 0, wickets: 0, matches: 0 };
          }
          newStats[bowler].balls += 1;
          newStats[bowler].runs += runs + (extra === 'noball' || extra === 'wide' ? 1 : 0);

          // If wicket for bowler (not run out)
          if (wicketType && wicketType !== 'Run Out') {
            newStats[bowler].wickets += 1;
          }
          return newStats;
        });
      }

      // Undo last ball
      function undoLastBall() {
        if (undoStack.current.length === 0) return;
        const prevState = undoStack.current.pop();
        setInningsData(prevState);
      }

      // Calculate winner after match end
      function calculateWinner() {
        // Sum of team runs innings 1 & 3 for team A
        const teamARuns = inningsData[0].runs + inningsData[2].runs;
        const teamBRuns = inningsData[1].runs + inningsData[3].runs;

        if (teamARuns > teamBRuns) {
          setWinnerTeam('A');
        } else if (teamBRuns > teamARuns) {
          setWinnerTeam('B');
        } else {
          setWinnerTeam('Draw');
        }
      }

      // PDF export
      function exportMatchPDF() {
        const doc = new jsPDF();

        doc.setFontSize(16);
        doc.text('Street Cricket Match Summary', 10, 10);
        doc.setFontSize(12);
        doc.text(`Toss Winner: Team ${tossWinner}`, 10, 20);
        doc.text(`Toss Choice: ${tossChoice === 'bat' ? 'Batting' : 'Bowling'}`, 10, 28);
        doc.text(`Match Ended: ${matchEnded ? 'Yes' : 'No'}`, 10, 36);

        let y = 48;
        // Loop innings summaries
        for (let i = 0; i < inningsData.length; i++) {
          const inn = inningsData[i];
          if (!inn) continue;
          doc.setFontSize(14);
          doc.text(`Innings ${i + 1} - Runs: ${inn.runs} Wickets: ${inn.wickets} Overs: ${inn.overs}`, 10, y);
          y += 8;

          doc.setFontSize(12);
          const players = (i % 2 === 0) ? teamAPlayers : teamBPlayers;

          for (let p = 0; p < TEAM_SIZE; p++) {
            const bs = inn.batsmanStats[p];
            const name = players[p];
            let outText = bs.isOut ? `Out (${bs.outType}${bs.fielder ? ', Fielder: ' + bs.fielder : ''})` : 'Not Out';
            doc.text(
              `${name}: Runs ${bs.runs}, Balls ${bs.balls}, ${outText}`,
              10,
              y
            );
            y += 6;
            if (y > 280) {
              doc.addPage();
              y = 20;
            }
          }
          y += 8;
        }

        // Career stats
        doc.addPage();
        doc.setFontSize(16);
        doc.text('Career Stats Leaderboard', 10, 10);
        const sortedPlayers = Object.entries(careerStats).sort((a, b) => b[1].runs - a[1].runs);
        y = 20;
        doc.setFontSize(12);
        for (const [player, stats] of sortedPlayers) {
          const average = stats.balls > 0 ? (stats.runs / stats.balls).toFixed(2) : '0';
          doc.text(
            `${player} - Runs: ${stats.runs}, Balls: ${stats.balls}, Wickets: ${stats.wickets}, Matches: ${stats.matches}, Avg: ${average}`,
            10,
            y
          );
          y += 6;
          if (y > 280) {
            doc.addPage();
            y = 20;
          }
        }

        doc.save(`MatchSummary_${Date.now()}.pdf`);
      }

      // Handle day end
      function onDayEnd() {
        setDayEnded(true);
        alert('Day ended. Scoring paused. You can resume next day.');
      }
      // Handle new day start (resume)
      function onNewDay() {
        setDayEnded(false);
        alert('New day started. Scoring resumed.');
      }

      // Render UI
      if (!matchStarted) {
        return (
          <div className="bg-slate950 p-6 rounded-md max-w-2xl mx-auto shadow-lg text-white">
            <h1 className="text-3xl font-bold mb-4 text-accentBlue">Street Cricket Scorer</h1>

            {/* Team A Players */}
            <div className="mb-4">
              <h2 className="text-xl font-semibold text-accentGreen mb-1">Team A Players</h2>
              {teamAPlayers.map((p, i) => (
                <input
                  key={i}
                  type="text"
                  className="w-full mb-1 rounded px-2 py-1 text-black"
                  value={p}
                  onChange={e => {
                    const newPlayers = [...teamAPlayers];
                    newPlayers[i] = e.target.value;
                    setTeamAPlayers(newPlayers);
                  }}
                />
              ))}
            </div>

            {/* Team B Players */}
            <div className="mb-4">
              <h2 className="text-xl font-semibold text-accentGreen mb-1">Team B Players</h2>
              {teamBPlayers.map((p, i) => (
                <input
                  key={i}
                  type="text"
                  className="w-full mb-1 rounded px-2 py-1 text-black"
                  value={p}
                  onChange={e => {
                    const newPlayers = [...teamBPlayers];
                    newPlayers[i] = e.target.value;
                    setTeamBPlayers(newPlayers);
                  }}
                />
              ))}
            </div>

            {/* Toss Winner */}
            <div className="mb-4">
              <h2 className="text-xl font-semibold text-accentBlue mb-2">Select Toss Winner</h2>
              <div className="flex space-x-4">
                <button
                  className={`flex-1 py-2 rounded bg-accentBlue hover:bg-blue-700 ${tossWinnerSelection === 'A' ? 'ring-4 ring-accentGreen' : ''}`}
                  onClick={() => setTossWinnerSelection('A')}
                >
                  Team A
                </button>
                <button
                  className={`flex-1 py-2 rounded bg-accentBlue hover:bg-blue-700 ${tossWinnerSelection === 'B' ? 'ring-4 ring-accentGreen' : ''}`}
                  onClick={() => setTossWinnerSelection('B')}
                >
                  Team B
                </button>
              </div>
            </div>

            {/* Toss Choice */}
            {tossWinnerSelection && (
              <div className="mb-4">
                <h2 className="text-xl font-semibold text-accentBlue mb-2">Toss Winner Choice</h2>
                <div className="flex space-x-4">
                  <button
                    className={`flex-1 py-2 rounded bg-accentGreen hover:bg-green-700 ${tossChoiceSelection === 'bat' ? 'ring-4 ring-accentBlue' : ''}`}
                    onClick={() => setTossChoiceSelection('bat')}
                  >
                    Batting
                  </button>
                  <button
                    className={`flex-1 py-2 rounded bg-accentGreen hover:bg-green-700 ${tossChoiceSelection === 'bowl' ? 'ring-4 ring-accentBlue' : ''}`}
                    onClick={() => setTossChoiceSelection('bowl')}
                  >
                    Bowling
                  </button>
                </div>
              </div>
            )}

            {/* Team Batting Choice */}
            {(tossWinnerSelection && tossChoiceSelection) && (
              <div className="mb-6">
                <h2 className="text-xl font-semibold text-accentBlue mb-2">Other Team Choice</h2>
                <div className="flex space-x-4">
                  <button
                    className={`flex-1 py-2 rounded bg-accentGreen hover:bg-green-700 ${teamABattingChoice === 'bat' ? 'ring-4 ring-accentBlue' : ''}`}
                    onClick={() => setTeamABattingChoice('bat')}
                  >
                    Team A Batting
                  </button>
                  <button
                    className={`flex-1 py-2 rounded bg-accentGreen hover:bg-green-700 ${teamABattingChoice === 'bowl' ? 'ring-4 ring-accentBlue' : ''}`}
                    onClick={() => setTeamABattingChoice('bowl')}
                  >
                    Team A Bowling
                  </button>
                </div>
              </div>
            )}

            {/* Next Button */}
            {(tossWinnerSelection && tossChoiceSelection) && (
              <button
                className="w-full py-3 bg-accentBlue rounded text-white font-bold text-lg hover:bg-blue-700"
                onClick={() => {
                  setTossWinner(tossWinnerSelection);
                  setTossChoice(tossChoiceSelection);
                  // Set batting team based on toss choice
                  if (tossWinnerSelection === 'A') {
                    setBattingTeam(tossChoiceSelection === 'bat' ? 'A' : 'B');
                  } else {
                    setBattingTeam(tossChoiceSelection === 'bat' ? 'B' : 'A');
                  }
                  setMatchStarted(true);
                  setCurrentBowlerIndex(0); // default bowler
                }}
              >
                Start Match
              </button>
            )}

            {/* Leaderboard */}
            <Leaderboard careerStats={careerStats} />
          </div>
        );
      }

      // Player name helper for batting team
      const battingPlayers = battingTeam === 'A' ? teamAPlayers : teamBPlayers;
      const bowlingPlayers = battingTeam === 'A' ? teamBPlayers : teamAPlayers;

      // Current innings data shortcut
      const currentInnings = inningsData[innings - 1];

      // Partnership runs: sum of striker + non-striker runs in current innings
      const partnershipRuns = currentInnings
        ? currentInnings.batsmanStats[strikerIndex].runs + currentInnings.batsmanStats[nonStrikerIndex].runs
        : 0;

      // Render main match UI
      return (
        <div className="max-w-3xl mx-auto p-4 bg-slate950 rounded-md shadow-lg">

          {/* Header */}
          <h1 className="text-3xl font-bold mb-4 text-accentBlue text-center">Street Cricket Scorer</h1>

          {/* Match Info */}
          <div className="flex justify-between mb-4">
            <div>Innings: {innings} ({battingTeam === 'A' ? 'Team A Batting' : 'Team B Batting'})</div>
            <div>Overs: {currentInnings.overs}.{currentBallInOver}</div>
            <div>Wickets: {currentInnings.wickets} / {MAX_WICKETS}</div>
          </div>

          {/* Run Rate */}
          <div className="mb-4 flex justify-between text-accentGreen">
            <div>Run Rate: {runRate.toFixed(2)}</div>
            {(innings === 2 || innings === 4) && (
              <div>Required RR: {requiredRunRate.toFixed(2)}</div>
            )}
          </div>

          {/* Batting players */}
          <div className="mb-4 grid grid-cols-2 gap-4 text-white">
            {[strikerIndex, nonStrikerIndex].map((idx, i) => {
              const isStriker = i === 0;
              const player = battingPlayers[idx];
              const stats = currentInnings.batsmanStats[idx];
              return (
                <div
                  key={idx}
                  className={`p-4 rounded border ${isStriker ? 'border-accentGreen animate-pulse-green' : 'border-accentBlue'}`}
                >
                  <div className="font-bold text-lg">{player} {isStriker ? '(Striker)' : '(Non-Striker)'}</div>
                  <div>Runs: {stats.runs}</div>
                  <div>Balls: {stats.balls}</div>
                  <div>{stats.isOut ? `Out (${stats.outType}${stats.fielder ? `, Fielder: ${stats.fielder}` : ''})` : 'Not Out'}</div>
                </div>
              );
            })}
          </div>

          {/* Buttons for runs */}
          <div className="mb-4 grid grid-cols-4 gap-2">
            {[0,1,2,3,4,6].map(run => (
              <button
                key={run}
                className="bg-accentBlue py-3 rounded text-white font-semibold hover:bg-blue-700"
                onClick={() => onBall({runs: run, batsmanRuns: run})}
                disabled={dayEnded || matchEnded}
              >
                {run} Run{run !== 1 ? 's' : ''}
              </button>
            ))}
          </div>

          {/* Extras buttons */}
          <div className="mb-4 flex space-x-2">
            <button
              className="flex-1 bg-accentGreen py-3 rounded text-white font-semibold hover:bg-green-700"
              onClick={() => setShowExtraRunInput('wide')}
              disabled={dayEnded || matchEnded}
            >
              Wide
            </button>
            <button
              className="flex-1 bg-accentGreen py-3 rounded text-white font-semibold hover:bg-green-700"
              onClick={() => setShowExtraRunInput('noball')}
              disabled={dayEnded || matchEnded}
            >
              No Ball
            </button>
          </div>

          {/* Extra run input popup */}
          {showExtraRunInput && (
            <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
              <div className="bg-slate950 rounded p-6 max-w-sm w-full">
                <h3 className="text-xl font-bold mb-2 text-white">{showExtraRunInput === 'wide' ? 'Wide Ball' : 'No Ball'} - Select runs scored by batsman</h3>
                {showExtraRunInput === 'noball' && (
                  <p className="mb-2 text-white text-sm">Note: Batsman runs + 1 extra run will be added.</p>
                )}
                <input
                  type="number"
                  min="0"
                  max="6"
                  value={extraRunInput}
                  onChange={e => setExtraRunInput(parseInt(e.target.value) || 0)}
                  className="w-full p-2 rounded mb-4 text-black"
                />
                <div className="flex justify-end space-x-2">
                  <button
                    className="px-4 py-2 rounded bg-red-600 hover:bg-red-800 text-white"
                    onClick={() => {
                      setShowExtraRunInput(false);
                      setExtraRunInput(0);
                    }}
                  >
                    Cancel
                  </button>
                  <button
                    className="px-4 py-2 rounded bg-accentGreen hover:bg-green-700 text-white"
                    onClick={() => {
                      if (showExtraRunInput === 'wide') {
                        onBall({runs: 0, extra: 'wide', batsmanRuns: 0});
                      } else if (showExtraRunInput === 'noball') {
                        onBall({runs: extraRunInput, extra: 'noball', batsmanRuns: extraRunInput});
                      }
                      setShowExtraRunInput(false);
                      setExtraRunInput(0);
                    }}
                  >
                    Add
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Wicket button */}
          <button
            className="w-full bg-red-600 py-3 rounded text-white font-bold hover:bg-red-700 mb-4"
            onClick={() => {
              if (dayEnded || matchEnded) return;
              setWicketFalling(true);
              setSelectedWicketType(null);
              setSelectedFielder(null);
            }}
            disabled={dayEnded || matchEnded}
          >
            Wicket
          </button>

          {/* Wicket modal */}
          {wicketFalling && (
            <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
              <div className="bg-slate950 rounded p-6 max-w-sm w-full">
                <h3 className="text-xl font-bold mb-4 text-white">Select Wicket Type</h3>
                <div className="grid grid-cols-2 gap-3 mb-4">
                  {WICKET_TYPES.map(type => (
                    <button
                      key={type}
                      className={`py-2 rounded font-semibold ${selectedWicketType === type ? 'bg-accentGreen' : 'bg-accentBlue'}`}
                      onClick={() => {
                        setSelectedWicketType(type);
                        if (OUT_TYPES_WITH_FIELDER.includes(type)) {
                          // Show fielder picker
                          const otherPlayers = [...battingPlayers]
                            .filter((_, idx) => idx !== strikerIndex && idx !== nonStrikerIndex);
                          setFielderOptions(otherPlayers);
                          setFielderPickerVisible(true);
                        } else {
                          // No fielder selection needed, confirm wicket
                          confirmWicket(type, null);
                        }
                      }}
                    >
                      {type}
                    </button>
                  ))}
                </div>
                <button
                  className="w-full py-2 bg-red-600 rounded text-white font-bold hover:bg-red-700"
                  onClick={() => setWicketFalling(false)}
                >
                  Cancel
                </button>
              </div>
            </div>
          )}

          {/* Fielder picker modal */}
          {fielderPickerVisible && (
            <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
              <div className="bg-slate950 rounded p-6 max-w-sm w-full">
                <h3 className="text-xl font-bold mb-4 text-white">Select Fielder</h3>
                <div className="grid grid-cols-2 gap-3 mb-4">
                  {fielderOptions.map((f, i) => (
                    <button
                      key={i}
                      className={`py-2 rounded font-semibold ${selectedFielder === f ? 'bg-accentGreen' : 'bg-accentBlue'}`}
                      onClick={() => setSelectedFielder(f)}
                    >
                      {f}
                    </button>
                  ))}
                </div>
                <div className="flex space-x-2">
                  <button
                    className="flex-1 py-2 bg-red-600 rounded text-white font-bold hover:bg-red-700"
                    onClick={() => {
                      setFielderPickerVisible(false);
                      setWicketFalling(false);
                    }}
                  >
                    Cancel
                  </button>
                  <button
                    className="flex-1 py-2 bg-accentGreen rounded text-white font-bold hover:bg-green-700"
                    onClick={() => {
                      if (selectedFielder) {
                        confirmWicket(selectedWicketType, selectedFielder);
                        setFielderPickerVisible(false);
                        setWicketFalling(false);
                        setSelectedFielder(null);
                      } else {
                        alert('Please select a fielder');
                      }
                    }}
                  >
                    Confirm
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Undo button */}
          <button
            className="w-full bg-yellow-500 py-3 rounded text-black font-bold hover:bg-yellow-600 mb-4"
            onClick={undoLastBall}
            disabled={dayEnded || matchEnded}
          >
            Undo Last Ball
          </button>

          {/* Day controls */}
          {!dayEnded ? (
            <button
              className="w-full bg-purple-700 py-3 rounded text-white font-bold hover:bg-purple-800 mb-4"
              onClick={onDayEnd}
            >
              End Day
            </button>
          ) : (
            <button
              className="w-full bg-purple-500 py-3 rounded text-white font-bold hover:bg-purple-600 mb-4"
              onClick={onNewDay}
            >
              New Day - Resume Scoring
            </button>
          )}

          {/* Export PDF */}
          <button
            className="w-full bg-green-600 py-3 rounded text-white font-bold hover:bg-green-700"
            onClick={exportMatchPDF}
          >
            Export Match & Career Summary PDF
          </button>

          {/* Winner display */}
          {matchEnded && (
            <div className="mt-8 p-4 bg-accentGreen rounded text-black text-center text-2xl font-bold">
              {winnerTeam === 'Draw'
                ? 'Match Drawn!'
                : `Team ${winnerTeam} Wins! üèÜüéâ`}
            </div>
          )}
        </div>
      );

      // Confirm wicket handler
      function confirmWicket(type, fielder) {
        onBall({
          runs: 0,
          extra: null,
          wicketType: type,
          fielder,
          batsmanRuns: 0,
        });

        // New batsman comes to replace striker
        const newBatsmanIndex = currentInnings.batsmanStats.findIndex(bs => !bs.isOut && ![strikerIndex, nonStrikerIndex].includes(bs));
        // If all out or no new batsman left - game ends innings
        if (newBatsmanIndex === -1) {
          alert('All out!');
          setInnings(innings + 1);
          if (innings >= 4) setMatchEnded(true);
          return;
        }

        // Replace striker with new batsman
        setStrikerIndex(newBatsmanIndex);
      }
    }

    // Leaderboard Component
    function Leaderboard({ careerStats }) {
      const sorted = Object.entries(careerStats).sort((a, b) => b[1].runs - a[1].runs);
      return (
        <div className="mt-8 bg-slate800 p-4 rounded text-white max-w-2xl mx-auto">
          <h2 className="text-xl font-bold mb-2 text-accentBlue">Career Stats Leaderboard</h2>
          {sorted.length === 0 && <p>No career stats yet.</p>}
          <table className="w-full text-left text-sm">
            <thead>
              <tr>
                <th className="border-b border-gray-600 py-1">Player</th>
                <th className="border-b border-gray-600 py-1">Runs</th>
                <th className="border-b border-gray-600 py-1">Balls</th>
                <th className="border-b border-gray-600 py-1">Wickets</th>
                <th className="border-b border-gray-600 py-1">Matches</th>
                <th className="border-b border-gray-600 py-1">Average</th>
              </tr>
            </thead>
            <tbody>
              {sorted.map(([player, stats]) => {
                const avg = stats.balls ? (stats.runs / stats.balls).toFixed(2) : '0';
                return (
                  <tr key={player} className="border-b border-gray-700">
                    <td className="py-1">{player}</td>
                    <td className="py-1">{stats.runs}</td>
                    <td className="py-1">{stats.balls}</td>
                    <td className="py-1">{stats.wickets}</td>
                    <td className="py-1">{stats.matches}</td>
                    <td className="py-1">{avg}</td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      );
    }

    // Render app
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
